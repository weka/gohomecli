package cli

import (
	"github.com/spf13/cobra"
	"github.com/weka/gohomecli/internal/client"
	"github.com/weka/gohomecli/internal/utils"
	"strconv"
)

func init() {
	rootCmd.AddCommand(eventsCmd)
	eventsCmd.Flags().BoolVar(&eventsCmdArgs.HideInternal, "hide-internal", false,
		"do not show internal events")
	eventsCmd.Flags().BoolVarP(&eventsCmdArgs.ReverseSort, "reverse", "r", false,
		"sort events from oldest to newest")
	eventsCmd.Flags().BoolVar(&eventsCmdArgs.ShowEventIDs, "show-event-ids", false,
		"show event UUID generated by Weka Home")
	eventsCmd.Flags().BoolVar(&eventsCmdArgs.ShowIngestTime, "show-ingest-time", false,
		"show event ingest time")
	eventsCmd.Flags().BoolVar(&eventsCmdArgs.ShowProcessingTime, "show-processing-time", false,
		"show event processing time")
	eventsCmd.Flags().BoolVar(&eventsCmdArgs.SortByIngestTime, "by-ingest-time", false,
		"sort events by ingest time")
}

var eventsCmdArgs = struct {
	HideInternal       bool
	ReverseSort        bool
	ShowEventIDs       bool
	ShowIngestTime     bool
	ShowProcessingTime bool
	SortByIngestTime   bool
}{}

var eventsCmd = &cobra.Command{
	Use:     "events",
	Aliases: []string{"events"}, // backward compatibility
	Short:   "Show events",
	Long:    "Show events",
	Args:    cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		if eventsCmdArgs.ReverseSort {
			// Need server side support for this. Legacy CLI used to get a single
			// page of events and then reverse it, but here we want to support
			// pagination so we have to have the server do the sorting.
			utils.UserError("--reverse is not supported yet")
		}
		clusterID := args[0]
		api := client.GetClient()
		query, err := api.QueryEvents(clusterID, &client.EventQueryOptions{
			WithInternalEvents: !eventsCmdArgs.HideInternal,
			SortByIngestTime: eventsCmdArgs.SortByIngestTime,
		})
		if err != nil {
			utils.UserError(err.Error())
		}
		query.Options.NoAutoFetchNextPage = true
		headers := []string{"Time", "Type", "Category"}
		if eventsCmdArgs.ShowEventIDs {
			headers = append(headers, "UUID")
		}
		if eventsCmdArgs.ShowIngestTime {
			headers = append(headers, "Cloud Time")
		}
		headers = append(headers,
			"Is Backend", "Node", "Org ID", "Permission", "Processed", "Severity")
		if eventsCmdArgs.ShowProcessingTime {
			headers = append(headers, "Processing Time")
		}
		utils.RenderTableRows(headers, func() []string {
			event, err := query.NextEvent()
			if err != nil {
				utils.UserError(err.Error())
			}
			if event == nil {
				return nil
			}
			row := utils.NewTableRow(len(headers))
			row.Append(
				FormatTime(event.Time),
				FormatEventType(event.EventType),
				event.Category,
				)
			if eventsCmdArgs.ShowEventIDs {
				row.Append(FormatUUID(event.CloudID))
			}
			if eventsCmdArgs.ShowIngestTime {
				row.Append(FormatTime(event.IngestTime))
			}
			row.Append(
				FormatBoolean(event.IsBackend),
				FormatNodeID(event.NodeID),
				strconv.FormatInt(event.OrganizationID, 10),
				event.Permission,
				FormatBoolean(event.Processed),
				FormatEventSeverity(event.Severity),
			)
			if eventsCmdArgs.ShowProcessingTime {
				duration := event.ComputeProcessingTime()
				row.Append(strconv.FormatFloat(duration, 'f', 2, 64))
			}
			return row.Cells
		})
	},
}
